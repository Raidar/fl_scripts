.Language=English,English
.PluginContents=
.Options CtrlColorChar=\

@Contents
$    #Scripts for the luafar4editor#
    fl_scripts
    для LuaFAR for Editor
    ~О Lua~@lua@

    ~Скрипты~@Scripts@
    ~Файлы конфигурации~@config@
    ~Зависимости~@requirements@

    ~Helper Scripts~@HelperScripts@

    ~Благодарности~@thanx@

    Автор: maxfl
    mailto:gmaxfl@@gmail.com

@requirements
$    #Зависимости#
    fl_scripts зависит от пакета ~context~@http://forum.farmanager.com/viewtopic.php?f=11&t=5140@, который необходим для нормальной работы скриптов.
    Посредством context осуществляются все настройки определения типов файлов и управление файлами конфигурации.

    ~Назад в contents~@Contents@

@thanx
$   #Благодарности#
    Большое Спасибо Shmuel за LuaFAR.

    Не менее большое Спасибо Shmuel и Aidar за помощь и полезные советы.

    ~Назад в contents~@Contents@

@lua
$    #О Lua#
#Типы данных:#
    #nil#      - ничего
    #boolean#  - булевские переменные
    #number#   - числа
    ~string~@lua_string@   - строки
    ~table~@lua_table@    - таблицы
    #function# - функции

#Операторы:#
    #+#, #-#, #*#, #/# - арифметические операции: сложение, вычитание, умножение, деление
    #%# - остаток от деления
    #^# - возведение в степень
    ~..~@lua_string@ - "конкатенация", сложение строк
    #<# #># #<=# #>=# - сравнение
    #==# #~~=# - равно, не равно
    #and# - логическое И
    #or# - логическое ИЛИ
    #not# - логическое НЕ ("not true" -> "false")
   # ## # - оператор длины (~строки~@lua_string@, массива)

#Приоритет операторов:#
    #^#
    #not# # ## # #- (unary)#
    #*# #/# #%#
    #+# #-# #..#
    #<# #># #<=# #>=# #~~=# #==#
    #and#
    #or#

#Комментарии:#
    #--#             - комментарий до конца строки
    #--[[# ... #]]--#  - многострочный комментарий

#Присвоение:#
    #a=5 b="hi"#             - a=5, b="hi"
    #local a=a#              - локальные переменные действуют только в пределах текущего блока кода: функция, условие if и т. д.
    #a, b, c = 1, 2, 3#      - множественное присвоение: a=1, b=2, c=3
    #a, b = b, a#            - перестановка
    #a, b = 4, 5, "6"#       - a=4, b=5, строка "6" пропадает
    #a = nil#                - уничтожает a
    #a = z#                  - если z не определено, тоже самое, что a=nil
    #a, b = "there"#         - a="there", b=nil

    ~Назад в contents~@Contents@

@lua_string
$    #Строки в Lua#
Строка в Lua может быть задана разными способами:

1) Используя одинарные кавычки:
   #'строка lua'#      -> строка lua
   #'строка "lua"'#    -> строка "lua"
   #'строка \'lua\''#  -> строка 'lua'
   #'z:\\\\my\\\\folder'#    -> z:\my\folder

2) Используя одинарные кавычки:
   #"строка lua"#      -> строка lua
   #"строка 'lua'"#    -> строка 'lua'
   #"строка \"lua\""#  -> строка "lua"
   #"z:\\\\my\\\\folder"#    -> z:\my\folder

3) Используя #[[# и #]]#:
   #[[#
   #   это#
   #   многострочная#
   #   строка#
   #   'Lua"#
   #   с путём:#
   #   z:\my\folder#
   #]]#

3а) Используя #[=[# и #]=]# (или #[==[# и #]==]#, или #[===[# и #]===]# и.д.) Каждый вариант игнорирует все остальные, сеодржащиеся внутри:
   #[==[#
   #   это#
   #   многострочная#
   #   строка#
   #   'Lua"#
   #   с путём:#
   #   z:\my\folder#
   #   и скобками [[ ]] и [=[ ]=]#
   #]==]#

Строки типа 1 и 2 чувствительны к escape-последовательностям:
    #\a# - "звонок"
    #\b# - backspace
    #\f# - form feed
    #\n# - новая строка
    #\r# - возврат каретки
    #\t# - горизонтальный таб
    #\v# - вертикальный таб
    #\\\\# - обратный слеш
    #\"# - двойная кавычка
    #\'# - одинарная кавычка
    #\[# и #\]# - квадратные скобки
    #\\ddd# - символ, заданный десятичным кодом ddd

Строка типа 3 игнорирует все escape-последовательности.

#Операции над строками:#

1) Конкатенация, сложение строк производится при помощи оператора #..#
    #"abc"..'def'# -> abcdef

    #a='abc'#
    #a..'def'# -> abcdef

Если в конкатенации участвуют числа, lua конвертирует их в строки:
    #'a'..2# -> a2
    #(2)..3# -> строка 23   ( двойка взята в скобки что-бы не было ошибки из-за того, что 2..3 похоже на неправильно записанную дробь 2.3 )

2) Арифметическое сложение автоматически конвертирует строки в числа:
   #'2'+'3'# -> число 5
   #'2'+3#   -> число 5
    #2+'3'#  -> число 5

3) Длина строки: оператор# ## #возвращает длину строки, включая нули:
   # ##'abcd' # -> 4
   # ##'abcd\\000f' # -> 6
   Тоже самое делает функция #string.len(s)#

    ~Назад в Lua~@lua@

@lua_table
$    #Таблицы в Lua#
 #t = {}# - создаёт пустую таблицу

 #t = {"yes", "no", "?"}# - простой массив, элементы t[1]="yes", t[2]="no", t[3]="?".

 #t = { [1] = "yes", [2] = "no", [3] = "?" }# - тоже самое, только с явно заданными индексами

 #t = {[-900] = 3, [+900] = 4}# - "разделенный" массив с двумя элементами

 #t = {x=5, y=10}# - таблица с полями t["x"]=5, t["y"]=10
                   или t.x=5, t.y=10
                   запись t["x"] и t.x эквивалентны

 #t = {x=5, y=10; "yes", "no"}# - смешанный вариант, поля/элементы: t.x=5, t.y=10, t[1]="yes", t[2]="no"

Тоже самое:
 #t = {"yes", "no"} #
 #t.x=5 #
 #t["y"]=10#

Тоже самое:
 #t = {}#
 #t.x=5#
 #t.y=10#
 #t[1]="yes"#
 #t[2]="no"#

#t = {msg = "choice", {"yes", "no", "?"}}# - таблицы могут содержать другие таблица как элементы

#ПРИМЕЧАНИЯ:#
    1) Нумерация массивов начинается с #1#
    2) Ключи и элементы таблицы могут быть любого типа, кроме #nil#.
    3) Обращение к полям таблицы при помощи синтаксиса table.field возможно если поле начинается с буквы и не содержит спецсимволов.
       #Правильно:# table.a23, table['~~sdfd'], table['23']
       #Не правильно:# table.23, table.~~sdf

    ~Назад в Lua~@lua@

@config
$    #Файлы конфигурации#
Стандартные файлы конфигурации находятся в папке fl_scripts/cfg.
Пользователь может скопировать любой конфигуранионный файл в папку fl_scripts/usrcfg и изменять по своему усмотрению.

Если файл конфигурации не найден ни в одной из папок, выводится сообщение об ошибке.

    ~Назад в contents~@Contents@


@Scripts
$    #Scripts#

    #Общие:#
        ~Калькулятор            (calc.lua)~@calc@
        ~Обновление макросов    (reload_macro.lua)~@reload_macro@
        ~Список экранов         (screens.lua)~@screens@

    #Редактор:#
        ~Переход по выделению   (block.lua)~@block@
        ~Смещение выделения     (blockindent.lua)~@blockindent@
        ~Комментирование        (comment.lua)~@comment@
        ~Копирование верхнего/нижнего символа (copysymbol.lua)~@copysymbol@
        ~Обработка событий редактора (editor_actions.lua)~@editor_actions@
        ~Удаление лишних пробелов и пустых строк (kill_spaces.lua)~@kill_spaces@
        ~Навигация              (nav.lua)~@nav@
        ~Поиск секций           (sections.lua)~@sections@
        ~Расширенное выделение  (select.lua)~@select@
        ~Smartkeys              (smartkeys.lua)~@smartkeys@
        ~Вставка шаблонов       (template.lua)~@template@
        ~Мультибуфер            (multiclip.lua)~@multiclip@

    #Панели:#
        ~Переход по выделению   (selection_jump.lua)~@selection_jump@
        ~Фильтр панели          (panelfilter.lua)~@panelfilter@
        ~Работа с алиасами      (alias.lua)~@alias@
        ~Winepath               (winepath.lua)~@winepath@

    #Примеры:#
        ~Меню файловой системы  (fs_menu.lua)~@fs_menu@
        ~Адресная книга Opera   (opera_mail.lua)~@opera_mail@
        ~Кей-логгер             (keylogger.lua)~@keylogger@

    ~Назад в contents~@Contents@

@HelperScripts
$    #HelperScripts#

    Скрипты для общего использования. Находятся в папке utils.
    Каждый скрипт, при вызове возвращает функцию, которую и надо использовать.

    ~Итератор выделения     (block_iterator.lu)~@block_iterator@
    ~"Очистка" пути         (clear_path.lua)~@clear_path@
    ~Деревообразное меню    (treemenu.lua)~@treemenu@
    ~Разворачиваемое меню   (wrapmenu.lua)~@wrapmenu@

    ~Назад в contents~@Contents@

@block_iterator
$    #Итератор выделения (block_iterator.lua)#

    При загрузке возвращает генератор итератора выделения (:.
    Единственный аргумент указывает возвращать ли текущую строку, если выделение отсутствует.

    #Использование:#
       local farselection=require'scripts/utils/block_iterator'
       for i,str in #farselection(true)# do
           function(str)
       end

    #i#   - номер строки
    #str# - строка, возвращаемая функцией far.EditorGetString(nil,i,1)

    ~Назад в Helper Scripts~@HelperScripts@

@clear_path
$    #"Очистка" пути (clear_path.lua)#
    Функция clear_path(str) "очищает" путь:
    - разворачивает разделители (/ -> \)
    - удаляет все парные разделители и конструкции типа ".\"
    - убирает все конструкции типа "folder\..\"

    Возвращает "очищенный" путь.

    ~Назад в Helper Scripts~@HelperScripts@

@block
$    #Переход по выделению (block.lua)#
    Содержит две функции:
        #jumptoblockbegin()# - переход на начало выделения.
        #jumptoblockend()#   - переход на конец выделения.

    #Использует:#
        ~block_iterator.lua~@block_iterator@

    ~Назад в Scripts~@Scripts@

@blockindent
$    #Переход по выделению (blockindent.lua)#
    Содержит две функции:
        #indentleft()#  - смещение пробелами на длину табуляции влево.
        #indentright()# - смещение пробелами на длину табуляции вправо.

    #Использует:#
        ~block_iterator.lua~@block_iterator@

    ~Назад в Scripts~@Scripts@

@calc
$    #Калькулятор (calc.lua)#

    Небольшой калькулятор. Написан в первую очередь для проверки работы диалогов и скорости сборки скриптов lua.
    Запускается при выполнении скрипта.
    #Свойства:#
        - синтаксис lua
        - функции из math находятся в _G
        - сборка на лету. Указание этапа работы на котором произошла ошибки
        - 4 строки вывода с настраиваемым форматом (см. lua:string.format)
        - если в строке есть команда return, результатом вычисления считается возвращаемое значение
        - поддерживаются пользовательские функции.

    Пользовательские функции хранятся в папке functions. Зачитываются все файлы. 
    Что-бы функция была видна из калькулятора, она должна быть задана глобально.
    Краткая справка пишется в том же файле в таблицу help. Вызывается из калькулятора по F1.
    Для справки см. уже определённые функции fib, fact, mean, sum.

    ~Назад в Scripts~@Scripts@

@reload_macro
$    #Обновление макросов (reload_macro.lua)#
    Заставляет фар перечитать макросы из реестра.

    ~Назад в Scripts~@Scripts@

@screens
$    #Список экранов (screens.lua)#
    Список экранов фара с возможностью фильтра.
    #Горячие клавиши:#
        F2 - Сохранить файл.
        Del - Закрытый файл (несохраненные файлы не закрываются).
        Right - Установить путь активной панели на текущий файл.

    ~Назад в Scripts~@Scripts@

@nothing
$    #Ничего#
    #здесь ничего нет...#

    И ~назад~@nothing@ отсюда нельзя!

@comment
$    #Комментирование (comment.lua)#
    Скрипт для расстановки и снятия комментариев. Корректно работает как со строчными комментариями, так и блочными.

    Конфигурация #scripts/config/comment_config#:
        Для каждого типа работают три параметра: #line#, #left#, #right#.
        #line#       - строчный комментарий.
        #left#,#right# - левая и правая часть блочного комментария.
        #skipSpaces# - если #true#, то строчный комментарий добавляется не с начала строки, а перед первым непробельным символом.


    #Пример:# types.c= { line='//', left='/*', right='*/', skipSpaces=true }

    #Порядок работы#:
    1) Выделен поточный блок или нет выделения:
        - если есть line, то ставит комментарий в начале каждой строки.
        - иначе, если есть left и right то комментирует область целиком.
    2) Выделен вертикальный блок:
        - если есть left и right, то в каждой строке выделения ставит left/right на начало/конец выделения.
        - иначе, если есть line, то аналогично первому случаю.
    Раскомментирование отличается только тем, что комментарий (line или left/right) ищется в любой позиции. Удаляется самый левый.

    #Использует:#
        ~block_iterator.lua~@block_iterator@

    ~Назад в Scripts~@Scripts@

@copysymbol
$    #Копирование верхнего/нижнего символа (copysymbol.lua)#
    #copysymbolup()#   - вставляет в текущую позицию редактора символ, находящийся на предыдущей строке.
    #copysymboldown()# - вставляет в текущую позицию редактора символ, находящийся на следующей строке.

    ~Назад в Scripts~@Scripts@

@editor_actions
$    #Обработка событий редактора (editor_actions.lua)#
    Файл, который в _usermenu зарегистрирован в MakeResident. Единственная функция вызывается при получении события от редактора и вызывает скрипты:
    #Открытие:#
       ~Настройка редактора (init_config.lua)~@init_config@
       ~Вставка шаблонов (templates_menu.lua)~@templates_menu@

    #Сохранение:#
       ~Удаление лишних пробелов и пустых строк (kill_spaces.lua)~@kill_spaces@

    ~Назад в Scripts~@Scripts@

@kill_spaces
$    #Удаление лишних пробелов и пустых строк (kill_spaces.lua)#
    Удаляет лишние пробелы в конце строк и пустые строки в конце файла (кроме одной).

    Конфигурация #scripts/config/editor_config#:
        types.binary = { lock=true }

    ~Назад в Scripts~@Scripts@

@nav
$    #Навигация (nav.lua)#
    #navigate()# - навигация.
    #navigate_current()# - навигация только по текущему элементу.
    #source()# - переход к связанному файлу.
    #nav_menu()# - меню. Показывает меню с вызовом 3-х предыдущих элементов.

    Конфигурация #scripts/config/nav_config#:
        types.c= { patterns={'^%s-[##]include%s+["<]([^"<>]+)[">]$'},
                   paths={".","%INCLUDE%","..\\include"},
                   --extensions={},
                   source_paths={'..\\src','.'},
                   source_extensions={'.cxx','.cc','.C','.cpp'} }

        Настройки навигации:
            patterns - таблица с шаблонами для поиска имен файлов в тексте. Скобки указывают на часть, соответствующую имени файла.
            paths    - таблица с путями поиска. Допустимы переменные среды.
            extensions - таблица с допустимыми расширениями. Если указана, расширения по очереди добавляются к найденной строке.
        Настройки поиска парного файла.
            source_paths - таблица с путями поиска. Допустимы переменные среды.
            source_extensions - таблица с допустимыми расширениями. Если указана, расширения по очереди добавляются к найденной строке.

    #Порядок работы#:
        #navigate()#:
            - Сканирует текст на соответствие шаблону patterns. Собирает имена файлов.
            - Ищет файлы в путях paths. Если указана таблица extensions, перебирает файлы, прибавляя расширения из таблицы.
            - Показывает меню с найденными файлами. В меню работает поиск.

        #navigate_current()# - тоже самое, только вместо всего файла используется только текущая строка.

        #source()#:
            - В путях source_paths ищет файл с именем, как у текущего, заменяя расширение на строки из source_extensions.
            - Для не найденных вариантов добавляет пункт "Create".
            - Показывает меню. В меню работает поиск.

    Все показываемые меню являются разворачиваемыми (см. ~wrapmenu~@wrapmenu@), т. е. можно произвести навигацию по любому файлу
    из меню. Результат "развернется" в текущее меню (клавиша Right). Переход в подменю по enter запрещен.

    #Использует:#
        ~wrapmenu.lua~@wrapmenu@
        ~clear_path.lua~@clear_path@

    ~Назад в Scripts~@Scripts@

@sections
$    #Поиск секций (sections.lua)#
    Ищет в файле разделы. Выводит меню со строками и возможностью поиска.

    Конфигурация #scripts/config/section_config#:
        Основной конфигурационный параметр - поле pattern. pattern может быть как строкой так и таблицей.
        Возможные варианты:
            1) pattern - строка:
               При поиске секций строка из редактора сравнивается с шаблоном pattern.
            2) pattern - таблица, без дополнительных полей:
               При поиске секций строка из редактора сравнивается поочередно с каждым элементом из таблицы pattern до первого совпадения.
               Каждый элемент может быть как строкой, так и таблицей.
            3) pattern - таблица с полем multiline:
               Используется для определение многострочных шаблонов.
               При поиске секций строка из редактора сравнивается с первым элементом таблицы pattern, следующая строка - со вторым элементом и т.д (по количеству элементов).
               Совпадение учитывается если все строки совпали с шаблонами. Каждый элемент может быть как строкой, так и таблицей.
               По умолчанию в меню добавляется строка, соответствующая первому шаблону.
               Если в таблице pattern существует поле linetoshow, то в меню добавляется строка, соответствующая шаблону с номером linetoshow (нумерация начинается с 1).


    #Пример#:
        Таблица с шаблонами:
        types.lua= { pattern={ 'local%s+function%s+[%w_%.:]+%s-%([^%)]-%)',
                               'function%s+[%w_%.:]+%s-%([^%)]-%)',
                               'local%s+[%w_%.:]+%s-=%s-function%s-%([^%)]-%)',
                               '[%w_%.:]+%s-=%s-function%s-%([^%)]-%)' } }

        Многострочный шаблон. Совпадает если первая строка пуста или содержит только пробелы,
        а вторая содержит текст в []-скобках. В меню добавляет текст, совпавший со вторым шаблоном.
        types.ini= { pattern={ '^%s-$', '^%[.+%]', multiline=true, linetoshow=2 } }

        patterns - таблица с шаблонами для поиска.

    ~Назад в Scripts~@Scripts@

@select
$    #Расширенное выделение (select.lua)#
    #exselect(bool)#:
        - при первом вызове начинает выделение блока.
        - при втором - выделяет. Если вызвать с true, то выделяет вертикальный блок.

    ~Назад в Scripts~@Scripts@

@smartkeys
$    #Smartkeys              (smartkeys.lua)#
    #smarthome()# - Переход не первый непробельный символ. Если уже на нём - переход на начало. С начала - на первый непробельный и т.д.
    #smarttab()#  - Переход на ближайшую позицию, над которой стоит непробельный символ и перед надом которой есть как минимум два пробела.

    ~Назад в Scripts~@Scripts@

@template
$    #Вставка шаблонов (template.lua)#
При создании файла вызывает меню с доступными шаблонами.
Скрипт написан из интереса: насколько гибкими получатся шаблоны.

#Порядок работы#:
    - определяет тип строчных комментариев, используемых в файле. Если из нет, используется символ ##.
    - При создании нового файла проверяет наличие директорий scripts/templates_user/<type> и scripts/templates/<type>
      Папка fl_scripts/templates - шаблоны, идущие в комплекте с fl_scripts.
      Папка fl_scripts/templates_user - пользовательские шаблоны. Имеют более высокий приоритет, чем стандартные шаблоны.
      Тип берется из context если он там указан, иначе берется тип-родитель, родитель родителя и т.д.
      Т.е. шаблоны для hlf файла будут искаться в следующем порядке:
        1) fl_scripts/templates_user/far_hlf, fl_scripts/templates/far_hlf
        2) fl_scripts/templates_user/far, fl_scripts/templates/far
        3) fl_scripts/templates_user/markup, fl_scripts/templates/markup
        4) ...
        5) fl_scripts/templates_user/default, fl_scripts/templates/default
    - Если директория существует - показывает меню со всеми шаблонами из неё.
    - Выбранный шаблон подставляется в файл.

Шаблоны позволяют использовать код на lua и функции, экспортируемые farlua4editor.
Все первые строки шаблона, начинающиеся с "<комментарий>@@@@" интерпретируются как lua-код. В этой области можно задавать функции.
Всё, что находится после строки, начинающейся не с "<комментарий>@@@@" интерпретируется как шаблон.
В этой области допустимы вставки кода:
- @@@@ return a @@@@ - вставляет 'a' как строку.
- @@@@ fun() fun2() @@@@ - выполняет функции fun() и fun2()
- вставки типа @@@@ ... @@@@ должны быть однострочными.

#Дополнительные функции#:
    #here()#    - установка курсора.
    #push(str)# - печать строки str.
    #defer(f)#  - выполнить функцию f после вставки шаблона.

#Пример использования#:
    см. scripts/example/example.templ
    можно создать файл 1.example и посмотреть как это работает.

#Использует:#
    ~Настройки comment.lua~@comment@

~Назад в Scripts~@Scripts@

@multiclip
$    #Мультибуфер (multiclip.lua)#
    Буфер обмена с более произвольным количеством ячеек. Работает фильтр.
    #Горячие клавиши:#
        Del - Удалить ячейку.
        Ctrl+Del - Удалить все ячейки.
        Ins - Заменить ячейку текстом из выделения или текущей строки.
        Right - Создать новую ячейку с текстом из выделения или текущей строки.
        Ctrl+Right - Создать новые ячейки (отдельно для каждой строки).
        Ctrl+Ins - Копировать содержимое ячейки в буфер обмена.
        Shift+Ins - Заменить содержимое ячейки текстом из буфера обмена.

    ~Назад в Scripts~@Scripts@

@selection_jump
$    #Переход по выделению (selection_jump.lua)#
    #selection_jump_next()#  - переход на следующий выделенный файл.
    #selection_jump_prev()#  - переход на предыдущий выделенный файл.
    #selection_jump_first()# - переход на первый выделенный файл.
    #selection_jump_last()#  - переход на последний выделенный файл.

    ~Назад в Scripts~@Scripts@

@panelfilter
$    #Фильтр панели (panelfilter.lua)#
Скрипт реализует фильтр панели. Действие скрипта аналогично действию плагина panelfilter от jbak.
Скрипт добавляет в меню LuaFar два пункта:
    1) Panel Filter - запуск фильтра панели
    2) Panel Filter: delete - удаление фильтра панели из списка фильтров (вызываемого CtrlI)

#Как это работает#:
    После запуска фильтра над панелью (над пунктом ..) появляется область, отображающая текущее состояние фильтра.
    Фильтрация элементов панели осуществляется после добавления к фильтру любого символа.
    Esc выходит из режима фильтрации, выключает и удаляет фильтр.
    Enter закрывает диалог, но оставляет фильтр включенным.

#Как это работает 1#:
    После любого изменения строки фильтра скрипт закрывает диалог и при помощи макроса вызывает список фильтров,
    создает/изменяет фильтр #_luafilter_# и вызывает себя же из командной строки.
    Текст используемого макроса доступен для редактирования в файле #panels/panelfilter.lua# в многострочном виде (после cтроки #'local fil=([['#).
    Единственная оговорка: все символы #%# должны быть удвоены (т. е. запись #%%a=1;# на самом деле означает #%a=1;#)

    ~Назад в Scripts~@Scripts@

@alias
$    #Работа с алиасами (alias.lua)#
Простой скрипт который реализует работу с алиасами. При вызове заменяет содержимое командной строки на соответствующий ему алиас, если такой имеется и выполняет его.

#Конфигурация (config/filter_config.lua):#

return {
         home = 'cd /home/%user%',
         farhome = 'cd %farhome%',
         ['~~config'] = 'edit:%farhome%/plugins/luafareditor/scripts/experimental/config/alias_config.lua '
       }

При вызове скрипта, когда в командной строке стоит текст 'home' приведет у выполнению команды 'cd /home/%user%' и т. д.
Поле ~~config записано как ['~~config'], т. к. начинается не с буквы.

    ~Назад в Scripts~@Scripts@

@fs_menu
$    #Меню файловой системы (fs_menu.lua)
    Пример использования разворачиваемого меню.
    Запускается командой "Lua script".
    Находится в папке "examples".

    #Использует:#
        ~wrapmenu.lua~@wrapmenu@

    ~Назад в Scripts~@Scripts@

@opera_mail
$    #Адресная книга Opera (opera_mail.lua)#
    Пример использования разворачиваемого меню.
    Запускается командой "Lua script".
    Находится в папке "examples".

    #Использует:#
        ~wrapmenu.lua~@wrapmenu@

    ~Назад в Scripts~@Scripts@

@keylogger
$    #Кей-логгер (keylogger.lua)#
    Выводит диалог в котором печатает все нажатые клавиши. Выходит по Esc или Enter.

    ~Назад в Scripts~@Scripts@

@winepath
$    #Winepath (winepath.lua)#
    Заменяет все абсолютные пути из командной строки на линуксовые.

    #Использует:#
        winepath -u <path>

    ~Назад в Scripts~@Scripts@
